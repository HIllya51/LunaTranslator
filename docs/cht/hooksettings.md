# HOOK 設定

## 通用設定

1. #### 字碼頁

    ::: info
    這一設定當且僅當從遊戲中擷取的文字是 **HOOK 引擎內部未指定編碼**的**多位元組字串**時才有意義。當 HOOK 引擎內部已經指定了字碼頁，或者文字是**寬字元字串**或者 **UTF-32** 字串時，這一設定沒有任何意義。
    :::

    這一設定一般沒有修改的必要，若且唯若部份古老引擎（例如 Yuris）的官方中文版可能會有 GBK/BIG5/UTF-8。如果找不到正確的文字，直接向我發 [Issue](https://lunatranslator.org/Resource/game_support)，修改這個設定通常是徒勞的。

1. #### 重新整理延遲

    如果你面臨以下情況之一：

        1. 文字每次就擷取出一兩個字；
        2. 文字每次擷取出一行，然後把上一行頂掉，最後只顯示最後一行；
        3. 文字正確，但是擷取得好慢；

    那麼你需要調整這個選項。

    對於 **1、2** 兩種情況，因為遊戲文字顯示得太慢了，而重新整理延遲太低，導致每擷取到一兩個字、或者擷取到一行文字，就立即重新整理出來了。對此，你需要做的是，**提高重新整理延遲**，或者提高遊戲的文字顯示速度。

    對於 **3**，你可以**適當地降低重新整理延遲**，降低設定值的同時注意不要出現 **1、2** 的情況。

1. #### 最大緩衝區長度

    有時，文字會反覆地不停重新整理，這時，如果重新整理延遲較高且不能降低，會導致一直接收文字直到文字填滿緩衝區、或不再重新整理以滿足重新整理延遲（通常是遊戲失去焦點時才停止重新整理，因此一般是等到填滿緩衝區）。

    為了解決這個問題，可以適當降低緩衝區長度，且要注意不要使緩衝區長度過低到小於實際文字長度。

1. #### 最大快取文字長度

    接收到的歷史文字會被快取下來，當在文字選擇視窗中，查看某項文字的內容時，會查詢歷史快取文字。如果文字條目過多，或因文字反覆重新整理時，會導致快取的文字過多，查看文字時會變得較為卡頓（有時甚至不查看時也會卡頓）。實際上這裡快取的大部份都是無用文字，有用的歷史文字可以在歷史文字視窗裡面查看，可以將這個數值隨意調低（預設是`1000000`，但其實調到`1000`就行）。

1. #### 最大允許輸出文字長度

   當遊戲進行跳過或查看歷史文字等時候，會一下子輸出許多文字，但其實對這些文字不感興趣。可以將這個值調整為一個適當的值，以過濾突發的大量文字輸出。

## 遊戲的專用設定

1. #### 額外的勾點
    1. #### Win32 通用勾點
        啟用後，將會向遊戲中注入 Win32 的通用函式勾點，包括 GDI 函式、D3DX 函式、字串函式。

        注入太多的勾點可能導致遊戲速度變慢，因此預設不會注入這些勾點。

        當無法擷取到正確的文字時，可以嘗試啟用這個選項。

    1. #### 特殊碼
        當**插入特殊碼**並**選中特殊碼的文字**時，才會記錄這項特殊碼，下一次啟動時會自動插入這項特殊碼。這個設定中記錄了之前記錄的所有特殊碼，可以在其中新增或刪除特殊碼。

1. #### 延遲注入
    有時，遊戲需要被插入勾點的位置在 DLL 上，需要遊戲稍微執行一下後，才會載入 DLL。我們也需要等 DLL 載入後，再進行注入。

1. #### 專用 HOOK 設定
    在`設定`介面->`HOOK 設定`中，進行的設定是預設設定，當尚未為遊戲指定專用的 HOOK 設定時，會採用預設設定。

    若要對遊戲進行專用 HOOK 設定，需要在`遊戲管理`中，開啟`遊戲設定`介面，在其中的遊戲設定分頁中，切換到`HOOK`子分頁，取消`跟隨預設`後，即可為遊戲設定專用的 HOOK 設定。

    ::: details
    ![img](https://image.lunatranslator.org/zh/gamesettings/1.jpg)

    ![img](https://image.lunatranslator.org/zh/gamesettings/2.png)
    :::

## 特殊碼格式

1. #### HOOK

    `{H|B}{A|B|C|W|I|S|Q|U|V}[F][N][codepage#][padding+]data_offset[*deref_offset][:split_offset[*deref_offset]]@addr[:module[:func]]`

    `H`是 Inline Hook，`B`是 VEH Hook

    單字元：`A`／`B`是小端序／大端序的 MBCS，`C`是 UTF-8，`W`是 UTF-16，`I`是 UTF-32。

    字串：`S`是預設 ASCII 字串，`Q`是 UTF-16，`U`是 UTF-32，`V`是 UTF-8。

    `F`：每次讀取字串後新增換行符號。

    `N`：無視上下文。

    暫存器的`data_offset`：
      * 32 位元 EAX -4, ECX -8, EDX -C, EBX -10, ESP -14, EBP -18, ESI -1C, EDI -20
      * 64 位元 RAX -C, RBX -14, RCX -1C, RDX -24, RSP -2C, RBP -34, RSI -3C, RDI -44, R8 -4C, R9 -54, R10 -5C, R11 -64, R12 -6C, R13 -74, R14 -7C, R15 -84

1. #### JIT HOOK

    `{H|B}{A|B|C|W|I|S|Q|M|U|V}[F][N][codepage#][padding+]arg_index[*deref_offset][:split_offset[*deref_offset]]@{info}:JIT:{UNITY|YUZU|PPSSPP|VITA3K|RPCS3}`

    `arg_index`是 JIT 函式的參數 Index。`M`為 C# 字串，僅 Unity 可用。

    `UNITY`的`info`為：`[元件]:[命名空間]:[類別名稱]:[函式名稱]:[參數量]`。

    `YUZU`、`PPSSPP`、`VITA3K`、`RPCS3`的`info`為被模擬位址。

1. #### 內嵌

    `E[D][S][N|O]HOOKCODE`

    `E`是使用內嵌的標註，`HOOKCODE`是 JIT 特殊碼或 HOOK 特殊碼。

    `D`：寫入時轉換中文字元為日文字元集。

    `S`：擷取時使用 HOOKCODE 指定的文字擷取方式。

    `N`：寫入時建立新的字串並交換字串指標。

    `O`：寫入時在原字串上覆寫。

1. #### 直接記憶體讀取

    `R{S|Q|V|U}[codepage#]@addr`

    `R`是直接記憶體讀取的標誌。

    `S`是預設 ASCII 字串，`Q`是 UTF-16，`U`是 UTF-32，`V`是 UTF-8。