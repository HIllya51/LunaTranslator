## HOOK设置

1. #### 代码页

  ?> 这一设置当且仅当从游戏中提取的文本是**HOOK引擎内部未指定编码**的**多字节字符串**时才有意义，当HOOK引擎内部已经指定了代码页，或者文本是**宽字符字符串**或者**UTF32**字符串时，这一设置没有任何意义

  这一设置一般没有修改的必要，当且仅当部分古老引擎(例如Yuris)的官方中文版可能会有GBK/BIG5/UTF8。如果找不到正确的文本，直接向我发[issue](https://lunatranslator.org/Resource/game_support)，修改这个设置通常是徒劳的。

1. #### 刷新延迟

  ?> 相对来说，这个算是最实用的选项了

  如果你面临以下情况之一：

      1、文本每次就提取出一两个字；
      2、文本每次提取出一行，然后把上一行顶掉，最后只显示最后一行；
      3、文本正确，但是提取的好慢；

  那么你需要调整这个选项。

  对于**1、2**两种情况，因为游戏文本显示的太慢了，而刷新延迟太低，导致每提取到一两个字、或者提取到一行文本，就立即刷新出来了。对此，你需要做的是，**提高刷新延迟**，或者提高游戏的文显示速度。

  对于**3**，你可以**适当的降低刷新延迟**，降低值的同时注意不要出现**1、2**的情况。

1. #### 最大缓冲区长度

  有时，文本会反复的不停刷新，这时，如果刷新延迟较高且不能降低，会导致一直接收文本直到文本填满缓冲区、或不再刷新以满足刷新延迟(通常是游戏失去焦点时才停止刷新，因此一般是等到填满缓冲区)。

  为了解决这个问题，可以适当降低缓冲区长度，且要注意不要使缓冲区长度过低到小于实际文本长度。

1. #### 最大缓存文本长度

  接收到的历史文本会被缓存下来，当在文本选择窗口中，查看某条文本的内容时，会查询历史缓存文本。如果文本条目过多，或因文本反复刷新，会导致缓存的文本过多，查看文本时会变得较为卡顿(有时甚至不查看时也会卡顿)。实际上这里缓存的大部分都是无用文本，有用的历史文本可以在历史翻译里面查看，可以将这个数值随意调低（默认是1000000，但其实调到1000就行）。

1. #### 过滤包含乱码的文本行

  文本处理中的过滤乱码只会过滤掉其中的乱码字符，而这个过滤会在接收到文本时，如果检查到文本行中包含任意乱码字符，会将整行文本直接整个舍弃。当游戏刷新大量包含乱码的句子时，可以适当使用这个选项，来筛选掉无效句子，提高性能。

1. #### 使用YAPI注入

  这个选项有时可以稍微提高一下舒适度，但可能有兼容性问题，因此不推荐使用。

  <details>
    <summary>具体解释</summary>
  向游戏注入Dll时，一般注入Dll的进程和被注入Dll的进程需要有相同的位数。

  为解决这个问题，Luna一般通过shareddllproxy32和shareddllproxy64来分别向不同位数的游戏来注入Dll。

  但这个代理进程运行时，可能会被杀毒软件拦截一会儿，导致卡顿、或运行失败要重新再次运行。这时，可以用YAPI来直接使用Luna的主进程来进行Dll注入。

  YAPI中如果游戏进程和Luna进程的位数相同，则会正常注入；若位数不同，则会使用一段特殊的shellcode来实现注入。这也是LunaHost32.dll更容易被杀软查杀的一个原因。

  使用YAPI注入相对来说会更加流畅一丢丢。不过在Arm平板上使用时，可能会不兼容。

  当Luna运行在低权限，而游戏是管理员权限时，这个选项会失效，会回退到原本模式并请求权限来进行注入。
  </details>


## 默认设置和游戏的专用设置

在设置界面->HOOK设置中，进行的设置是默认设置，当未为游戏指定专用的HOOK设置时，会采用默认设置。

若要对游戏进行专用HOOK设置，需要在**游戏管理**中，打开**游戏设置**界面，在其中的游戏设置选择卡中，切换到HOOK子选项卡，取消**跟随默认**后，即可为游戏设置专用的HOOK设置。

1. #### 特殊码

  当**插入特殊码**并**选中特殊码的文本**时，才会记录这个条特殊码，下一次启动时会自动插入这条特殊码。这个设置中记录了之前记录的所有特殊码，可以在其中添加或删除特殊码。

1. #### 延迟注入

  有时，游戏需要被插入钩子的位置，在dll上，需要游戏稍微运行一小会儿后，才会加载dll。我们也需要等dll加载后，再进行注入


![img](https://image.lunatranslator.org/zh/gamesettings/1.jpg)

![img](https://image.lunatranslator.org/zh/gamesettings/2.jpg)


## 附录

### 特殊码格式

<a id="hookcode"></a>

1. #### HOOK

  {H|B}{A|B|C|W|I|S|Q|U|V}[F][N][codepage#][padding+]data_offset[*deref_offset][:split_offset[*deref_offset]]@addr[:module[:func]]

  H是inlineHook，B是vehhook

  单字符：A/B是小端/大端的mbcs，C是UTF8，W是UTF16，I是UTF32。

  字符串：S是默认ascii字符串，Q是UTF16，U是UTF32，V是UTF8。

  F：每次读取字符串后添加换行符

  N：无视上下文

  寄存器的data_offset：
    * 32位 -4 for EAX, -8 for ECX, -C for EDX, -10 for EBX, -14 for ESP, -18 for EBP, -1C for ESI, -20 for EDI
    * 64位 -C for RAX, -14 for RBX, -1C for RCX, -24 for RDX, and so on for RSP, RBP, RSI, RDI, R8-R15

1. #### JIT HOOK

  {H|B}{A|B|C|W|I|S|Q|M|U|V}[F][N][codepage#][padding+]arg_index[*deref_offset][:split_offset[*deref_offset]]@{info}:JIT:{UNITY|YUZU|PPSSPP|VITA3K|RPCS3}

  arg_index是JIT函数的参数index。M为C#字符串，仅UNITY可用。

  UNITY的info为：[程序集]:[命名空间]:[类名]:[函数名]:[参数量]

  YUZU/PPSSPP/VITA3K/RPCS3的info为被模拟地址

1. #### 内嵌

  E[D][S][N|O]HOOKCODE

  E是使用内嵌的标注，HOOKCODE是JIT特殊码或HOOK特殊码。

  D：写入时转换中文字符为日语字符集

  S：提取时使用HOOKCODE指定的文本提取方式

  N：写入时创建新的字符串并交换字符串指针

  O：写入时在原字符串上覆写

1. #### 直接内存读取

  R{S|Q|V|U}[codepage#]@addr

  R是直接内存读取的标志

  S是默认ascii字符串，Q是UTF16，U是UTF32，V是UTF8